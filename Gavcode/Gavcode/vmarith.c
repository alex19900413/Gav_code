//------------------------------------------------------------------------------
/*******************************************************
* 向量、矩阵运算函数 v1.2
* 2013.04.01
*******************************************************/
#include <math.h>
#include "vmarith.h"
#include "MotionAGV.h"
//--------(三维)---------------------------------------------------------------- 
// 向量相加
double* vadd(double A[3], double B[3], double R[3])
{
	R[0] = A[0] + B[0];
	R[1] = A[1] + B[1];
	R[2] = A[2] + B[2];
	return R;
}
// 向量相减
double* vsub(double A[3], double B[3], double R[3])
{
	R[0] = A[0] - B[0];
	R[1] = A[1] - B[1];
	R[2] = A[2] - B[2];
	return R;
}
// 向量乘常数
double* vmul(double A[3], double c, double R[3])
{
	R[0] = A[0] * c;
	R[1] = A[1] * c;
	R[2] = A[2] * c;
	return R;
}
// 向量取膜
double norm(double A[3])
{
	double temp;
	temp = sqrt(A[0] * A[0] + A[1] * A[1] + A[2] * A[2]);
	return temp;
}
// 向量叉乘
double* cross(double A[3], double B[3], double R[3])
{
	double Rt[3];

	Rt[0] = A[1] * B[2] - A[2] * B[1];
	Rt[1] = A[2] * B[0] - A[0] * B[2];
	Rt[2] = A[0] * B[1] - A[1] * B[0];
	R[0] = Rt[0];
	R[1] = Rt[1];
	R[2] = Rt[2];
	return R;
}

//--------(二维)----------------------------------------------------------------
// 二维向量相加
double* v2add(double A[2], double B[2], double R[2])
{
	R[0] = A[0] + B[0];
	R[1] = A[1] + B[1];
	return R;
}
// 二维向量相减
double* v2sub(double A[2], double B[2], double R[2])
{
	R[0] = A[0] - B[0];
	R[1] = A[1] - B[1];
	return R;
}
// 二维向量乘常数
double* v2mul(double A[2], double c, double R[2])
{
	R[0] = A[0] * c;
	R[1] = A[1] * c;
	return R;
}
// 二维向量取膜
double norm2(double A[2])
{
	double temp;
	temp = sqrt(A[0] * A[0] + A[1] * A[1]);
	return temp;
}

//--------(矩阵)----------------------------------------------------------------
//矩阵相乘 
matp matmul(double A[4][4], double B[4][4], double R[4][4])
{
	int i, j;
	double Rt[4][4];

	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 4; j++)
		{
			Rt[i][j] = A[i][0] * B[0][j] + A[i][1] * B[1][j] + A[i][2] * B[2][j] + A[i][3] * B[3][j];
		}
	}

	for (i = 0; i < 4; i++)
	{
		for (j = 0; j < 4; j++)
		{
			R[i][j] = Rt[i][j];
		}
	}

	return R;
}
//关节变换矩阵生成函数
matp Ltranmat(double link[4], double q, double T[4][4])
{
	double sq, cq, sa, ca;

	sq = sin(q + link[0]);
	cq = cos(q + link[0]);
	sa = sin(link[3]);
	ca = cos(link[3]);

	T[0][0] = cq;
	T[0][1] = -sq * ca;
	T[0][2] = sq * sa;
	T[0][3] = link[2] * cq;
	T[1][0] = sq;
	T[1][1] = cq * ca;
	T[1][2] = -cq * sa;
	T[1][3] = link[2] * sa;
	T[2][0] = 0;
	T[2][1] = sa;
	T[2][2] = ca;
	T[2][3] = link[1];
	T[3][0] = 0;
	T[3][1] = 0;
	T[3][2] = 0;
	T[3][3] = 1;

	return T;

}
// 旋转矩阵
matp trotx(double q, double T[4][4])
{
	T[0][0] = 1;
	T[0][1] = 0;
	T[0][2] = 0;
	T[0][3] = 0;
	T[1][0] = 0;
	T[1][1] = cos(q);
	T[1][2] = -sin(q);
	T[1][3] = 0;
	T[2][0] = 0;
	T[2][1] = sin(q);
	T[2][2] = cos(q);
	T[2][3] = 0;
	T[3][0] = 0;
	T[3][1] = 0;
	T[3][2] = 0;
	T[3][3] = 1;

	return T;
}
matp troty(double q, double T[4][4])
{
	T[0][0] = cos(q);
	T[0][1] = 0;
	T[0][2] = sin(q);
	T[0][3] = 0;
	T[1][0] = 0;
	T[1][1] = 1;
	T[1][2] = 0;
	T[1][3] = 0;
	T[2][0] = -sin(q);
	T[2][1] = 0;
	T[2][2] = cos(q);
	T[2][3] = 0;
	T[3][0] = 0;
	T[3][1] = 0;
	T[3][2] = 0;
	T[3][3] = 1;

	return T;
}
matp trotz(double q, double T[4][4])
{
	T[0][0] = cos(q);
	T[0][1] = -sin(q);
	T[0][2] = 0;
	T[0][3] = 0;
	T[1][0] = sin(q);
	T[1][1] = cos(q);
	T[1][2] = 0;
	T[1][3] = 0;
	T[2][0] = 0;
	T[2][1] = 0;
	T[2][2] = 1;
	T[2][3] = 0;
	T[3][0] = 0;
	T[3][1] = 0;
	T[3][2] = 0;
	T[3][3] = 1;

	return T;
}

//4x4单位矩阵
void unitmat(double T[4][4])
{
	T[0][0] = 1;
	T[0][1] = 0;
	T[0][2] = 0;
	T[0][3] = 0;
	T[1][0] = 0;
	T[1][1] = 1;
	T[1][2] = 0;
	T[1][3] = 0;
	T[2][0] = 0;
	T[2][1] = 0;
	T[2][2] = 1;
	T[2][3] = 0;
	T[3][0] = 0;
	T[3][1] = 0;
	T[3][2] = 0;
	T[3][3] = 1;
}
//-----------------------------------------------------------------------------------------------
//***:  add by wlqunr17/07/24_apply to AGV
//Fun:  R41=A44*B41
//----------------------------------------------------------------
matpp matmul44x41(double A[4][4], double B[4][1], double R[4][1]) {
	int i;
	double Rt[4][1];
	for (i = 0; i < 4; i++) {
		Rt[i][0] = A[i][0] * B[0][0] + A[i][1] * B[1][0] + A[i][2] * B[2][0]
			+ A[i][3] * B[3][0];
	}
	for (i = 0; i < 4; i++) {
		R[i][0] = Rt[i][0];
	}
	return R;
}
//-----------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------
//***:  add by wlqunr_17/07/24_apply to AGV
//Fun:  轮速=V_car2W_wheel()*车速
//INput： T[4][4]空数组
//   agv_r车轮半径, agv_w横向轮距, agv_l纵向轴距
//Output: 矩阵因数T[4][4]
//Disc:  （4个轮毂坐标和小车坐标的X轴正方向统一水平向右）
////------------------------------------------------------------------------
matp V_car2W_wheel(double agv_r, double agv_w, double agv_l, double T[4][4]) {
	T[0][0] = 1 / agv_r;
	T[0][1] = 1 / agv_r;
	T[0][2] = agv_l + agv_w;
	T[0][3] = 0;
	T[1][0] = -1 / agv_r;
	T[1][1] = 1 / agv_r;
	T[1][2] = -(agv_l + agv_w);
	T[1][3] = 0;
	T[2][0] = -1 / agv_r;
	T[2][1] = 1 / agv_r;
	T[2][2] = agv_l + agv_w;
	T[2][3] = 0;
	T[3][0] = 1 / agv_r;
	T[3][1] = 1 / agv_r;
	T[3][2] = -(agv_l + agv_w);
	T[3][3] = 0;
	return T;
}
//-----------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------
//***:  add by wlqunr_17/07/24_apply to AGV
//Fun:  车速=W_wheel2V_car*轮速
//INput： T[4][4]空数组
//   agv_r车轮半径, agv_w小车横向轮距, agv_l小车纵向轴距
//Output: 矩阵因数T[4][4]
//Disc:  （4个轮毂坐标和小车坐标的X轴正方向统一水平向右）
//------------------------------------------------------------------------
matp W_wheel2V_car(double agv_r, double agv_w, double agv_l, double T[4][4]) {
	T[0][0] = agv_r / 4;
	T[0][1] = -agv_r / 4;
	T[0][2] = -agv_r / 4;
	T[0][3] = agv_r / 4;
	T[1][0] = agv_r / 4;
	T[1][1] = agv_r / 4;
	T[1][2] = agv_r / 4;
	T[1][3] = agv_r / 4;
	T[2][0] = agv_r / (4 * (agv_l + agv_w));
	T[2][1] = -agv_r / (4 * (agv_l + agv_w));
	T[2][2] = agv_r / (4 * (agv_l + agv_w));
	T[2][3] = -agv_r / (4 * (agv_l + agv_w));
	T[3][0] = 0;
	T[3][1] = 0;
	T[3][2] = 0;
	T[3][3] = 0;
	return T;
}
//-----------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------
//***:  add by wlqunr_17/07/24_apply to AGV
//Fun:  小车坐标系=CoordConv()*世界坐标系
//INput： T[4][4]空数组
//   RX小车坐标系x轴相对于世界坐标系X轴旋转的角度，Xp、Yp小车原点的世界坐标
//Output: 矩阵因数T[4][4]
//--------------------------------------------------------------
matp CoordConv(double RX, double XP, double YP, double T[4][4]) {
	T[0][0] = cos(RX);
	T[0][1] = sin(RX);
	T[0][2] = 0;
	T[0][3] = XP;
	T[1][0] = -sin(RX);
	T[1][1] = cos(RX);
	T[1][2] = 0;
	T[1][3] = YP;
	T[2][0] = 0;
	T[2][1] = 0;
	T[2][2] = 1;
	T[2][3] = 0;
	T[3][0] = 0;
	T[3][1] = 0;
	T[3][2] = 0;
	T[3][3] = 1;
	return T;
}
//-----------------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------------
//***:  add by wlqunr_17/07/24_apply to AGV
//Fun:  世界坐标系=CoordConv2()*小车坐标系
//INput： T[4][4]空数组
//   RX小车坐标系x轴相对于世界坐标系X轴旋转的角度，Xp、Yp小车原点的世界坐标
//Output: 矩阵因数T[4][4]
//--------------------------------------------------------------
matp CoordConv2(double RX, double XP, double YP, double T[4][4]) {
	T[0][0] = cos(RX);
	T[0][1] = -sin(RX);
	T[0][2] = 0;
	T[0][3] = (YP*sin(RX)) - (XP*sin(RX));
	T[1][0] = sin(RX);
	T[1][1] = cos(RX);
	T[1][2] = 0;
	T[1][3] = -((YP*sin(RX)) - (XP*sin(RX)));
	T[2][0] = 0;
	T[2][1] = 0;
	T[2][2] = 1;
	T[2][3] = 0;
	T[3][0] = 0;
	T[3][1] = 0;
	T[3][2] = 0;
	T[3][3] = 1;
	return T;
}
//-----------------------------------------------------------------------------------------------
